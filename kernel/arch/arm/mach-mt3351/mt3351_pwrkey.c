
#include <linux/init.h>        /* For init/exit macros */
#include <linux/module.h>      /* For MODULE_ marcros  */

#include <mach/mt3351_reg_base.h>
#include <mach/mt3351_pmu_hw.h>
#include <mach/mt3351_wdt.h>
#include <mach/mt3351_PWRKEY.h>

#include <mach/irqs.h>
#include <linux/interrupt.h>
#include <linux/reboot.h>

// For pm_power_off function
//#include <linux/serial_8250.h>
//#include <linux/serial_core.h>
#include <linux/device.h>

MODULE_LICENSE("GPL");

#define DRV_WriteReg_16(reg, val) (*(volatile unsigned short * const)(reg)) = (val)
#define DRV_WriteReg_32(reg, val) (*(volatile unsigned int * const)(reg)) = (val)
#define DRV_Reg_16(reg) (*(volatile unsigned short * const)(reg))
#define DRV_Reg_32(reg) (*(volatile unsigned int * const)(reg))

extern void MT3351_IRQSensitivity(unsigned char code, unsigned char edge);
extern void MT3351_IRQMask(unsigned int line);
extern void MT3351_IRQUnmask(unsigned int line);
extern void MT3351_IRQClearInt(unsigned int line);

void PMU_PWRKEY_Enable(int reset_sec)
{
	volatile unsigned int tmp;
	/* 
	 * 0x80003000 : Watch Dog Timer,
	 * enable the reset signal generated by long pressed power key
	 */
	DRV_WriteReg_16(MT3351_WDT_MODE, 0x2200);
	
	/*
	 * PMU will count the PWRKEY press time by setting register 
	 * RG_PWRKEY_RSTB_EN=1 and RG_PWRKEY_RSTB_SEL
	 */
	tmp = DRV_Reg_32(PMU_CON22);
	tmp &= ~(RG_PWRKEY_RSTB_EN_MASK|RG_PWRKEY_RSTB_SEL_MASK);
	tmp |= (RG_PWRKEY_RSTB_EN_MASK&(1<<RG_PWRKEY_RSTB_EN_SHIFT));

	/*
	 * Set Long Press time : 0:3s; 1:5s; 2:8s ; 3:10s
	 */
	tmp |= (RG_PWRKEY_RSTB_SEL_MASK&(reset_sec<<RG_PWRKEY_RSTB_SEL_SHIFT));  

	DRV_WriteReg_16(PMU_CON22, tmp);
}
EXPORT_SYMBOL(PMU_PWRKEY_Enable);

unsigned int PMU_PWRKEY_GetNonDEBSignal(void)
{ 
	return ( ( DRV_Reg_32(PMU_CON28) ) & 0x0080 ) >> 7;   
}
EXPORT_SYMBOL(PMU_PWRKEY_GetNonDEBSignal);

unsigned int PMU_PWRKEY_GetDEBSignal(void)
{ 
	return ( ( DRV_Reg_32(PMU_CON28) ) & 0x0001 );   
}
EXPORT_SYMBOL(PMU_PWRKEY_GetDEBSignal);


void PMU_PwrKeyTest_LongPressThreeSeconds(void)
{
	/*
	 * Enable PWRKEY
	 */
	PMU_PWRKEY_Enable(0);
	
	/*
	 * Waiting for user's long press
	 */
	printk("[PWRKEY] Please Long Press PWR key 3 sec. to reset.\n");

	while(1);

	/*
	 * disable the reset signal generated by long pressed power key
	 */
	DRV_WriteReg_16(MT3351_WDT_MODE, 0x2204); 
	    
}
EXPORT_SYMBOL(PMU_PwrKeyTest_LongPressThreeSeconds);

void PMU_PwrKeyTest_LongPressFiveSeconds(void)
{
	/*
	 * Enable PWRKEY
	 */
	PMU_PWRKEY_Enable(1);
	
	/*
	 * Waiting for user's long press
	 */
	printk("[PWRKEY] Please Long Press PWR key 5 sec. to reset.\n");

	while(1);

	/*
	 * disable the reset signal generated by long pressed power key
	 */
	DRV_WriteReg_16(MT3351_WDT_MODE, 0x2204); 
	    
}
EXPORT_SYMBOL(PMU_PwrKeyTest_LongPressFiveSeconds);

void PMU_PwrKeyTest_LongPressEightSeconds(void)
{
	/*
	 * Enable PWRKEY
	 */
	PMU_PWRKEY_Enable(2);
	
	/*
	 * Waiting for user's long press
	 */
	printk("[PWRKEY] Please Long Press PWR key 8 sec. to reset.\n");

	while(1);

	/*
	 * disable the reset signal generated by long pressed power key
	 */
	DRV_WriteReg_16(MT3351_WDT_MODE, 0x2204); 
	    
}
EXPORT_SYMBOL(PMU_PwrKeyTest_LongPressEightSeconds);

void PMU_PwrKeyTest_LongPressTenSeconds(void)
{
	/*
	 * Enable PWRKEY
	 */
	PMU_PWRKEY_Enable(3);
	
	/*
	 * Waiting for user's long press
	 */
	printk("[PWRKEY] Please Long Press PWR key 10 sec. to reset.\n");

	while(1);

	/*
	 * disable the reset signal generated by long pressed power key
	 */
	DRV_WriteReg_16(MT3351_WDT_MODE, 0x2204); 
	    
}
EXPORT_SYMBOL(PMU_PwrKeyTest_LongPressTenSeconds);

void PMU_CheckDEBPwrKeySingal(void)
{
	//volatile unsigned int tmp;
	volatile unsigned int NonDEB_bit, DEB_bit;

	NonDEB_bit = PMU_PWRKEY_GetNonDEBSignal();
	DEB_bit = PMU_PWRKEY_GetDEBSignal();

	printk("[PWRKEY] Now : Not-de-bounced PWRKEY signal is %d\n", NonDEB_bit);
	printk("[PWRKEY] Now : De-bounced PWRKEY signal is %d\n", DEB_bit);
	printk("[PWRKEY] Please Just Press PWR key.\n");

	while(DEB_bit)
	{
		NonDEB_bit = PMU_PWRKEY_GetNonDEBSignal();
		DEB_bit = PMU_PWRKEY_GetDEBSignal();
	}        

	printk("[PWRKEY] Good job !! You press the PWR key!!.\n");
	printk("[PWRKEY] Now : Not-de-bounced PWRKEY signal is %d\n", NonDEB_bit);
	printk("[PWRKEY] Now : De-bounced PWRKEY signal is %d\n", DEB_bit);
}
EXPORT_SYMBOL(PMU_CheckDEBPwrKeySingal);

static void mt3351_PWRKEY_power_off(void)
{
	printk(KERN_ALERT "\n==> mt3351_PWRKEY_power_off : Release POWER-BB !!\n");

	// Release POWER-BB
	DRV_WriteReg_32(0xF002C07c, 0x0);
}

static irqreturn_t mt3351_PWRKEY_ISR(int irq, void *dev_id, struct pt_regs *regs)
{
	volatile unsigned int NonDEB_bit, DEB_bit;

	NonDEB_bit = PMU_PWRKEY_GetNonDEBSignal();
	DEB_bit = PMU_PWRKEY_GetDEBSignal();

	MT3351_IRQMask(MT3351_KPAD_IRQ_CODE);

	printk(KERN_ALERT "\n==> In mt3351_PWRKEY_ISR function !!\n");

	if (NonDEB_bit && DEB_bit)
	{
		printk(KERN_ALERT "\n==> Can do pm_power_off !!\n");	

		pm_power_off = mt3351_PWRKEY_power_off;

		kernel_power_off();
	}
	else
		printk(KERN_ALERT "\n==> Can not do pm_power_off !!\n");	
	
	MT3351_IRQClearInt(MT3351_IRQ_KPAD_CODE);

	MT3351_IRQUnmask(MT3351_IRQ_KPAD_CODE);
	
	return IRQ_HANDLED;
}

static int __init mt3351_PWRKEY_init(void)
{
	//int ret;

	printk(KERN_ALERT "**** mt3351_PWRKEY_init **** !!\n" );

	// re-use KPAD IRQ as PWRKEY IRQ
#if 0	
	MT3351_IRQSensitivity(MT3351_KPAD_IRQ_CODE, MT3351_EDGE_SENSITIVE);
	printk(KERN_ALERT "\n==> mt3351_PWRKEY_init : PWRKEY's IRQSensitivity = MT3351_EDGE_SENSITIVE\n");
	
	ret = request_irq(MT3351_KPAD_IRQ_CODE, mt3351_PWRKEY_ISR, SA_INTERRUPT, "mt3351_powerkey", NULL);
	if(ret != 0)
		printk(KERN_ALERT "\n==> mt3351_PWRKEY_init : Failed to request PWRKEY's irq (%d)\n", ret);
	else
		printk(KERN_ALERT "\n==> mt3351_PWRKEY_init : Success to request PWRKEY's irq\n");
#endif		
	return 0;
}

static void __exit mt3351_PWRKEY_exit (void)
{
	printk(KERN_ALERT "**** mt3351_PWRKEY_exit **** !! !!\n");
	return ;
}

module_init(mt3351_PWRKEY_init);
module_exit(mt3351_PWRKEY_exit);
